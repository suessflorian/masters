\documentclass{article}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{amsfonts}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{hyperref}
\usepackage{biblatex}
\addbibresource{sample.bib}
\title{COMPSCI 750: Computation Complexity \\ Second Assignment}
\author{Florian Suess}
\begin{document}
\maketitle

\section*{Computable Transformation}
We dive into the inards of the \emph{reverse string} function $\bm{R}$. Consider the very nifty recursive definition;
\begin{align*}
	\text{for } l \in \{0,1\} \text{ then } \bm{R}(l) = l \\
	\text{let } w \in \{0,1\}^* \text{ then } \bm{R}(lw) = \bm{R}(w)l
\end{align*}

\textbf{Preliminaries;} for $w \in \{0,1\}^*$, $w_i \in w$ refers to the letter in the \emph{i\textsuperscript{th}} position of $w$ (necessarily $0 < i \leq |w|$).

\subsubsection*{Lemma 1: $a,b \in \{0,1\}^*$ we have $\bm{R}(ab) = \bm{R}(b)\bm{R}(a)$.}
We prove this inductively by the length of $a$.

Trivially if $|a|=1$, $a=l\in \{0,1\}$, then $\bm{R}(ab)=\bm{R}(lb)=\bm{R}(b)l=\bm{R}(b)\bm{R}(y)$.

Assume that the claim is true for all $a$ of length $n$, and that $a=la'$ with $l\in \{0,1\}$ and $|a'|=n$ is of length $n+1$. Then we have
\begin{align*}
	\bm{R}(ab)=\bm{R}\bigl(l(a'b)\bigr)=\bm{R}(a'b)l=\bm{R}(b)\bm{R}(a')l=\bm{R}(b)\bm{R}(la')=\bm{R}(b)\bm{R}(a)
\end{align*}

By induction, we're finished.

\subsubsection*{Lemma 2: $\bm{R}(\bm{R}(w)) = w$ for all $w \in \{0,1\}^*$.}
We prove this inductively yet again on the length of $|w|$.

Suppose $|w| = 1$ then $w = l \in \{0,1\}$ by definition we have $\bm{R}(l) = l$.

Assume that for any $v \in \{0,1\}^*$ such that $|v| < |w|$, we have $\bm{R}(\bm{R}(v)) = v$. Now for this $w$, it must be the case that $w = lv$ for some other $l \in \{0,1\}$ and $v \in \{0,1\}^*$. Clearly $|v| < |w|$.


\begin{align*}
	\bm{R}(\bm{R}(w)) = \bm{R}(\bm{R}(lv)) = \bm{R}(\bm{R}(v)l) 
\end{align*}
... then crucially by \textbf{lemma 1} we continue to see;
\begin{align*}
	= \bm{R}(l)\bm{R}\bigl(\bm{R}(v)\bigr) = lv = w
\end{align*}

\subsubsection*{$\bm{R}$ is a bijection}
For \textbf{injectivity}, let's assume that for some $a,b \in {0,1}^*$ that $\bm{R}(a) = \bm{R}(b)$. By lemma 2, applying $\bm{R}$ both sides yields $a = b$. For \textbf{surjectivity}, given some $a \in \{0,1\}^*$, we can construct $\bm{R}(a) \in \{0,1\}^*$ such that $\bm{R}(\bm{R}(a)) = a$ by lemma 2.

\subsubsection*{Computability}
Although obvious, we can write a brief algorithm that shows by force the computable nature of $\bm{R}$.

\begin{algorithmic}[1]
	\REQUIRE $W = w_1w_2w_3...w_n$
	\IF{$W \text{ is } Empty$}
			\RETURN Empty 
	\ENDIF
	\STATE $W' = Empty$
	\STATE $i = |W| - 1$
	\WHILE{$i \geq 0$}
		\STATE $W' = W'W[i]$
		\STATE $i = i - 1$
	\ENDWHILE
	\RETURN $W'$ 
\end{algorithmic}

Clearly this algorithm halts nicely. As there is only one potential loop, which is administered via the variable $i$ which is monotonically decreasing to 0.

\subsubsection*{Lemma 3: $w_i \in w$, $w'_k \in \bm{R}(w)$, $k=|w|-i+1 \Rightarrow w_i = w'_k$}
We prove this inductively on the length of $w$.

If $|w| = 1$, then $w = l$ for $l\in \{0,1\}$ and by definition $\bm{R}(l) = l$. Given $w_i \in w$, set $k=|w|-i+1=1$. 
\begin{align*}
w_i = w_1 = l = R(w) = w_1 = w_k
\end{align*}
Now when $|v| < |w|$ we assume for $v_i$ we can set $k=|v|-i+1$ such that $v_i = v'_k \in R(v)$.

We can say $w = lv$ for some $l \in \{0,1\}$ and $v \in \{0,1\}^*$. Note: $|w|=|v|+1$. Consider $w_i \in w$.
\begin{itemize}
	\item if $i=1$, \\
		$\Rightarrow w_i=l$, and since $R(vl) = lR(v) = w'$, $k=|w|-i+1=1$ and $w'_k=w_i$
	\item if $i\not=1$, \\
		$\Rightarrow w_i\in v$, set $v' = R(v)$, by assumption, $w_i=v'_t$ if $t=|v|-i+1$ \\
		$\Rightarrow$ if $v'_t \in lR(v) = R(vl) = R(w)$, $w_i=v'_k$ if \\
		$k=t+1=|v|-i+1+1=|w|-i+1$.
\end{itemize}
By induction, we're finished.

\subsubsection*{$\bm{R}(w)$ and $w$ have equal number of Monochromatic Arithmetic Progressions}
Suppose we find a monochromatic progression in $w$ (where $|w|=n$) of length $k$. That is the substring;

\begin{align*}
	w_iw_{i+t}w_{i+2t}...w_{i+(k-1)t} \\
	\text{ where } 1 \leq i \text{ and } i+(k-1)t \leq n
\end{align*}

Such that all letters here are equal. Using \textbf{lemma 3} in great strides, we can systematically assemble the monochromatic progression in $w' = \bm{R}(w)$ of length $k$.

\begin{align*}
	w'_{n - (i+(k-1)t) + 1}w'_{n - (i+(k-2)t) + 1}...w'_{n - (i+t) + 1}w'_{n - i + 1}
\end{align*}

Where all letters are nessecarily equal by \textbf{lemma 3}. We rely on \textbf{lemma 2} to apply the same proof for the converse where for every monochromatic progression in $R(w)$ we can build one in $w$. And so this sufficiently shows that there is an equal number of monochromatic progressions in $w$ and $R(w)$.

\subsubsection*{Lemma 4: $|\bm{R}(w)|=|w|$}
We prove this inductively on the length of $w$.

If $|w| = 1$, then $w = l$ for $l\in \{0,1\}$ and by definition $\bm{R}(l) = l, |w|=|\bm{R}(w)|$.

Assume for $|v| < |w|$ that $|v| = |\bm{R}(v)|$.

$w = lv$ for some $v \in \{0,1\}^*$ and $l \in \{0,1\}$. Then...
\begin{align*}
	|\bm{R}(w)| = |\bm{R}(lv)| = |\bm{R}(v)l| = |\bm{R}(v)|+1 = |v|+1 = |w|
\end{align*}
By induction, we're finished.

\subsubsection*{There exists a c $>$ 0, $\forall w \in \{0,1\}^*, |K(w) - K(\bm{R}(w))| \leq c$}
Choose a $c > 0$. Note; by lemma 2, $K(w) \leq c_p + |\bm{R}(w)|$ where $c_p$ is some program encoding constant. By lemma 4 we see, $c_p + |\bm{R}(w)| = c_p + |w| \geq K(\bm{R}(w))$. Hence;

\begin{align*}
	|K(w) - K(\bm{R}(w))| = (c_p + |w|) - (c_p + |w|)| = 0 < c.
\end{align*}

As required.

\pagebreak
\section*{Research Question}
We consider the question \emph{can programs simulate the human mind?}. We begin with the formal arguments presented, for the negative, in Ahbinav Muraleedharan's provocative paper\footnote{"Turing Machines Cannot Simulate The Human Mind"}.

\subsection*{Negative}
Ahbinav constructs a mathematical argument - based around a very simple decision problem; "is your memory finite" in the context of both a Computing machine (effectively a Turing machine with finite memory) and Turing machine. He proves that no program can compute a correct answer to this decision problem without examining the memory tape of a arbitrary computing machine.\cite{ahbinav} Leaving us, in the case of arbitrarily big computing machines, undecided as to when to halt the program and declare the memory to be finite. This leads us to a key contrast between a human mathematician, the designer of the computing machine, of whom by definition can solve this problem. This is used to show the existence of a statement about a mathematical object that is incomputable for a Turing Machine but computable for a human mathematician. 

\subsection*{Negative}
Ahbinav constructs a separate mathematical thought experiment, building an argument over the question; \emph{can a humanoid robot perform all humanly doable tasks within any humanely operable environment}. He shows the sets of all possible objects are countably infinite by assumption that each object can be described by finitely many parameters. Godel numbering technique is used to drive an isomorphism between the set of objects and the natural numbers forcing the set of objects to be infinite, but countable.

Ahbinav defines the sets of environments to be uncountably infinite by describing these to be collections of objects forcing an isomorphism between the set of environments to the power set of objects. Then we finally define a task as an action sequence inside an environment. 

Ahbinav's primary argument here is a contrast between the necessary generation of "large" and unique action sequences of an uncountably infinite set of environments, representing all humanely doable tasks, and the "relatively small" set of action sequences that can be generated by a robot with a Turing Machine as a brain. This argument is used to highlight the limitations to the powers of discrete-state machines and demonstrates a Turing machine's incomprehensibility of the human brain.

\subsubsection*{Foreword to the affirmative}
Ahbinav doesn't spare much thought to the construction of arguments for the affirmative, so we instead focus on the subject of disapproval, the Church-Turing thesis argument.

\subsection*{Affirmative}
For all practical purposes, it remains that, the fundamental building block of our brain is the so called neuron. With the recent digitizing of the C. elegans worm, with a nervous powered a set of 302 neurons \cite{worm}, we demonstrated a simulation of a collection of neurons. Afterall, a neuron on it's own is a simple mechanism, describable as a function onto the natural numbers. Many neurons merely being many functions onto the natural numbers. The Church-Turing thesis asserts that any function on the natural numbers can be calculated by an effective method if and only if it is computable by a Turing machine\cite{church-turing}, and so we can reasonably build up to the quantity of neurons of the human brain, and thus in turn mimic the function of the human brain that itself is known to simulate the mind hence a Turing machine can simulate the human mind.

\subsection*{Affirmative}
The concrete definition of the human mind is ambiguous and leaves to the rise of interesting side argument, narrative beautifully driven by the Chinese Room \cite{chinese_room} argument, that perhaps it is instead more sought after to find a criterion of "human mind" and objectively leave the concept of the "human mind" unobtainable. The Turing test, an empirical definition of intelligence; if a machine's behavior cannot be differentiated from that of an intelligent human, it must be conceded that the machine possesses the same faculty as the human \cite{turing_test}. One then can build a program, that effectively lists a rulebook for interaction, that is worked on iteratively towards the objective pass of the Turing test. If we find the program to be indistinguishable from a human, who are you to say it fails to posses an ability a human has?

\pagebreak
\section*{Mathematical modelling}
In order to formalise the statement; "There exists a form of quantum randomness that is provable better than pseudo-randomness". We must break it in parts.

\subsubsection*{Pseudo-Randomness}
The widely accepted mechanism for a pseudo-randomn number generator today is a two stage function.

\begin{itemize}
	\item{Accepts a \emph{seed}.}
	\item{Deterministically generates a sequence based on this seed.}
\end{itemize}

Without loss of generality, we shall live in the space of bit strings $\{0, 1\}$. We can now formalise this pseudorandom mechanism via the function that returns a function;

\begin{align*}
	\bm{PR}: \{0,1\}^* \rightarrow (\bm{G}: \mathbb{N} \rightarrow \{0,1\})
\end{align*}

When we speak of pseudo-randomness, we think of sequences of the form $(S_n)_{n \in \mathbb{N}}$ where $S_n = G(s)(n)$ for some fixed seed $s$.

\subsubsection*{Quantum-Randomness}
Quantum-computing is fundamentally supported by the qubit; that is $\varphi = \alpha | 0\rangle + \beta | 1\rangle$. Which represents a superposition state, represented by the linear combination of the basis states $| 0\rangle$ and $| 1\rangle$. Where $\alpha$ and $\beta$ are complex numbers, restricted to $\alpha^2 + \beta^2 = 1$. 

When we speak of quantum-randomness, we think in particular a sequence of the form $(Q_n)_{n \in \mathbb{N}}$ where $Q_n$ is the measurement of some qubit.

\subsubsection*{Provably Better}
As per lecture; randomness is best known symptomatically through the following properties\footnote{I spend effort formalising the first property, and relax on the others as we won't be dwelling on the other properties too much for the purposes of this assignment question}

\begin{itemize}
	\item Unpredictability, that is given a $n$ expanded sequence (where $n$ is finite), $S_n=s_1s_2s_3...s_n$, there is no $f: \{0,1\}^n \times N \rightarrow \{0,1\}$ such that this function can emulate forever the sequence hence fourth; $S_{n+1} = f(s_1,s_2,s_3...s_n, 1), S_{n+2} = f(s_1,s_2,s_3...s_n, 2), ...$.
	\item Incompressibility, the impossibility of a $n$ expanded sequence (where $n$ can $\rightarrow \infty$), to be compressed.
	\item Typicality, random sequences passing every statistical test of randomness.
\end{itemize}

If we find a form of randomness, that is the sequence $R$, exerting more symptoms of randomness than another form of randomness, say $R'$. We say $R$ is a "provably better" form of randomness than $R'$.

\subsubsection*{Then the statement in can be formalised in the following way}
\begin{align*}
	\exists (Q_n)_{n \in \mathbb{N}} \text{ that exhibits stronger symptoms of randomness than } (Sn)_{n\in\mathbb{N}}
\end{align*}

\subsubsection*{Proof of this statement}
By definition $(Sn)_{n\in\mathbb{N}}$ is defined by a seed $k \in \{0,1\}^*$, $\bm{PR}: \{0,1\}^* \rightarrow \bigl(\bm{G}: \mathbb{N} \rightarrow \{0,1\}\bigr)$ would yield the pseudo-random generating function $\bm{G}_k: \mathbb{N} \rightarrow \{0,1\}$. The existence of this function shows that this sequence is clearly predictable.

We construct the qubit with $\alpha$, $\beta$ amplitudes that are equal. ie, suppose we have $\alpha = \beta = \frac{1}{\sqrt{2}}$ then we construct a quantum random generator sequence $(Q_n)_{n \in \mathbb{N}}$ that on each $n$ collapses the qubit $\varphi = \frac{1}{\sqrt{2}} | 0\rangle + \frac{1}{\sqrt{2}} | 1\rangle$. By definition the probability that this sequences returns a $1$, or $0$, are both $0.5$. Due to the fundamental nature of a qubit, it is indeterministic and incomputable.

Here we show that quantum-randomness is less predictable than any form of pseudo-randomness, hence it's provably better.

\emergencystretch=1em
\printbibliography

\end{document}
