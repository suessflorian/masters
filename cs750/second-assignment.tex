\documentclass{article}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{amsfonts}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{hyperref}
\title{COMPSCI 750: Computation Complexity \\ Second Assignment}
\author{Florian Suess}
\begin{document}
\maketitle

\section*{Computable Transformation}
We dive into the inards of the \emph{reverse string} function $\bm{R}$. Consider the very nifty recursive definition;
\begin{align*}
	\text{for } l \in \{0,1\} \text{ then } \bm{R}(l) = l \\
	\text{let } w \in \{0,1\}^* \text{ then } \bm{R}(lw) = \bm{R}(w)l
\end{align*}

\subsubsection*{Lemma 0: $a,b \in \{0,1\}^*$ we have $\bm{R}(ab) = \bm{R}(b)\bm{R}(a)$.}
Trivially if $|a|=1$, $a=l\in \{0,1\}$, then $\bm{R}(ab)=\bm{R}(lb)=\bm{R}(b)l=\bm{R}(b)\bm{R}(y)$.

Assume that the claim is true for all $a$ of length $n$, and that $a=la'$ with $l\in \{0,1\}$ and $|a'|=n$ is of length $n+1$. Then we have
\begin{align*}
	\bm{R}(ab)=\bm{R}\bigl(l(a'b)\bigr)=\bm{R}(a'b)l=\bm{R}(b)\bm{R}(a')l=\bm{R}(b)\bm{R}(la')=\bm{R}(b)\bm{R}(a)
\end{align*}

\subsubsection*{Lemma 1: $\bm{R}(\bm{R}(s)) = s$ for all $s \in \{0,1\}^*$.}
Inductively then, give some $l \in \{0,1\}$, then by definition we have $\bm{R}(l) = l$. Let $w \in \{0,1\}^*$ be something arbitrary, we now assume that for any $x \in \{0,1\}^*$ such that $|x| < |w|$, we have $\bm{R}(\bm{R}(x)) = x$. Now for this $w$, it must be the case that $w = lx$ for some other $l \in \{0,1\}$ and $x \in \{0,1\}^*$. Clearly $|x| < |w|$.

\begin{align*}
	\bm{R}(\bm{R}(w)) = \bm{R}(\bm{R}(lx)) = \bm{R}(\bm{R}(x)l) = \bm{R}(l)\bm{R}\bigl(\bm{R}(x)\bigr) = lx = w
\end{align*}

\subsubsection*{$\bm{R}$ is a bijection}
For \textbf{injectivity}, let's assume that for some $a,b \in {0,1}^*$ that $\bm{R}(a) = \bm{R}(b)$. By lemma 1, applying $\bm{R}$ both sides yields $a = b$. For \textbf{surjectivity}, given some $a \in \{0,1\}^*$, we can construct $\bm{R}(a) \in \{0,1\}^*$ such that $\bm{R}(\bm{R}(a)) = a$ by lemma 1.

\subsubsection*{Computability}
Although obvious, we can write a brief algorithm that shows by force the computable nature of $\bm{R}$.

\begin{algorithmic}[1]
	\REQUIRE $W = w_1w_2w_3...w_n$
	\IF{$W \text{ is } Empty$}
			\RETURN Empty 
	\ENDIF
	\STATE $W' = Empty$
	\STATE $i = |W| - 1$
	\WHILE{$i \geq 0$}
		\STATE $W' = W'W[i]$
		\STATE $i = i - 1$
	\ENDWHILE
	\RETURN $W'$ 
\end{algorithmic}

Clearly this algorithm halts nicely. As there is only one potential loop, which is administered via the variable $i$ which is monotonically decreasing to 0.

\subsubsection*{$\bm{R}(w)$ and $w$ have equal number of Monochromatic Arithmetic Progressions}
First we show that for every monochromatic arithmetic progression in $w$ there is one in $\bm{R}(w)$.

We operate inductively on the length of the progression, $k$.

If $k=1$...

\begin{align*}
	w_iw_{i+t}w_{i+2t}...w_{i+(k-1)t},
\end{align*}

% \subsubsection*{Corollary: $i \leq |w|, l_{|w| - i} \in \bm{R}(w) \Rightarrow l_{|w| - i}=w_i \in w$, for all $w \in \{0,1\}^*$}
% Inductively, give some $l \in \{0,1\}$, then by definition we have $\bm{R}(l) = l$. Given $i \leq |l|$, clearly $l_i \in l = l_i \in \bm{R}(l)$. Let $w \in \{0,1\}^*$ be something arbitrary, we now assume that for any $x \in \{0,1\}^*$ such that $|x| < |w|$, we have for any $i \leq |x|, x_i \in x = x_i \in \bm{R}(x)$.

\section*{Research Question}
We consider the question \emph{can programs simulate the human mind?}. We begin with the formal arguments presented, for the negative, in Ahbinav Muraleedharan's provocative paper\footnote{"Turing Machines Cannot Simulate The Human Mind"}.

\subsection*{Negative}
Ahbinav constructs a simple decision problem, "is your memory finite", and proves it as uncomputable for a Turing Machine. In stark contrast to that of it's creator, the human mathematician, who can trivially solve this problem.

\subsection*{Negative}

\subsection*{Positive}
For all practical purposes, it remains that, the fundamental building block of our brain is the so called neuron. A primitive simulation of this collection of neurons undisputably would mimic the nature of the human brain, and thus in turn mimic the function of the human brain that itself is known to simulate the mind. We have already fully digitized the C. elegans worm, with a nervous powered by a much smaller 302 neurons. \footnote{\url{https://newatlas.com/c-elegans-worm-neural-network/53296}}

\subsection*{Positive}

\pagebreak
\section*{Mathematical modelling}
In order to formalise the statement; "There exists a form of quantum randomness that is provable better than pseudo-randomness". We must break it in parts.

\subsubsection*{Pseudo-Randomness}
The widely accepted mechanism for a pseudo-randomn number generator today is a two stage function.

\begin{itemize}
	\item{Accepts a \emph{seed}.}
	\item{Deterministically generates a sequence based on this seed.}
\end{itemize}

Without loss of generality, we shall live in the space of bit strings $\{0, 1\}$. We can now formalise this pseudorandom mechanism via the function that returns a function;

\begin{align*}
	\bm{PR}: \{0,1\}^* \rightarrow (\bm{G}: \mathbb{N} \rightarrow \{0,1\})
\end{align*}

When we speak of pseudo-randomness, we think of sequences of the form $(S_n)_{n \in \mathbb{N}}$ where $S_n = G(s)(n)$ for some fixed seed $s$.

\subsubsection*{Quantum-Randomness}
Quantum-computing is fundamentally supported by the qubit; that is $\varphi = \alpha | 0\rangle + \beta | 1\rangle$. Which represents a superposition state, represented by the linear combination of the basis states $| 0\rangle$ and $| 1\rangle$. Where $\alpha$ and $\beta$ are complex numbers, restricted to $\alpha^2 + \beta^2 = 1$. 

When we speak of quantum-randomness, we think in particular a sequence of the form $(Q_n)_{n \in \mathbb{N}}$ where $Q_n$ is the measurement of some qubit.

\subsubsection*{Provably Better}
As per lecture; randomness is best known symptomatically through the following properties\footnote{I spend effort formalising the first property, and relax on the others as we won't be dwelling on the other properties too much for the purposes of this assignment question}

\begin{itemize}
	\item Unpredictability, that is given a $n$ expanded sequence (where $n$ is finite), $S_n=s_1s_2s_3...s_n$, there is no $f: \{0,1\}^n \times N \rightarrow \{0,1\}$ such that this function can emulate forever the sequence hence fourth; $S_{n+1} = f(s_1,s_2,s_3...s_n, 1), S_{n+2} = f(s_1,s_2,s_3...s_n, 2), ...$.
	\item Incompressibility, the impossibility of a $n$ expanded sequence (where $n$ can $\rightarrow \infty$), to be compressed.
	\item Typicality, random sequences passing every statistical test of randomness.
\end{itemize}

If we find a form of randomness, that is the sequence $R$, exerting more symptoms of randomness than another form of randomness, say $R'$. We say $R$ is a "provably better" form of randomness than $R'$.

\subsubsection{Then the statement in can be formalised in the following way}
\begin{align*}
	\exists (Q_n)_{n \in \mathbb{N}} \text{ that exhibits stronger symptoms of randomness than } (Sn)_{n\in\mathbb{N}}
\end{align*}

\subsubsection{Proof of this statement}
By definition $(Sn)_{n\in\mathbb{N}}$ is defined by a seed $k \in \{0,1\}^*$, $\bm{PR}: \{0,1\}^* \rightarrow \bigl(\bm{G}: \mathbb{N} \rightarrow \{0,1\}\bigr)$ would yield the pseudo-random generating function $\bm{G}_k: \mathbb{N} \rightarrow \{0,1\}$. The existence of this function shows that this sequence is clearly predictable.

We construct the qubit with $\alpha$, $\beta$ amplitudes that are equal. ie, suppose we have $\alpha = \beta = \frac{1}{\sqrt{2}}$ then we construct a quantum random generator sequence $(Q_n)_{n \in \mathbb{N}}$ that on each $n$ collapses the qubit $\varphi = \frac{1}{\sqrt{2}} | 0\rangle + \frac{1}{\sqrt{2}} | 1\rangle$. By definition the probability that this sequences returns a $1$, or $0$, are both $0.5$. Due to the fundamental nature of a qubit, it is indeterministic and incomputable.

Here we show that quantum-randomness is less predictable than any form of pseudo-randomness, hence it's provably better.

\end{document}
