\documentclass{article}

\newenvironment{answered}{\par\normalfont}{}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{algorithm}
\usepackage{algorithmic}
\title {Challenges}
\author {Florian Suess}
\begin{document}
\maketitle
\section{Loops and non-halting programs}

\begin{enumerate}
	\item A program containing a loop never halts and deciding if a program contains a loop is easy. Why?
	\begin{answered}
		As brought to light in slide 11, suppose a program has a line numbered its set of instructions. If we define the sequence of some program $P$ and input $v$, say $S(P, v)$ as the execution flow of the program in terms of the line number of the current executed instruction line number. We can identify if after some $n$th item in the sequence of $S(P,v)$ contains nothing but the repetive pattern (loops) of instructions $(x_1, x_2, ..., x_i)$ where $i$ simply represents the size of this loop.
	\end{answered}
\item \textbf{Show that the program below does not halt;}
\begin{verbatim}
 1 i=1
 2 while i >= 1 do 
 3   j = 1
 4   while j <= i do
 5     print 0
 6     j = j + 1
 7   end while	
 8   i = i + 1
 9 end while
10 stop
\end{verbatim}
 \begin{answered}
	 Define the sequence $S(i)$ as the of values set to $i$ as the program runs. As defined in line 1, it begins with 1. Filtering the instructions of the program to only changes to variable $i$... it's clear that $\forall n > 0, S(i)_n \geq 1$. Hence the program will never satisfy any condition other than $i \geq 1$, meaning the condition on line 2 will never fail thus never exiting the loop.
 \end{answered}

\pagebreak
\item \textbf{What is the largest decidable set for the Halting Problem}
	\begin{answered}
	Suppose for a moment that indeed we have the largest decidable set for the halting problem, call it $L$ (set of program input pairs), that means there exists a halting decider relative to $L$, call it $H$, that decidably determines for any $l \in L$, if $l$ halts. By the Halting Theorem there must be a program input pair out there, $P$ such that $P \not\in L$. That is, the halting decider $H$, cannot decidably determine wether $P$ halts.

	$P$ must either halt or not. Let's build upon $H$, halting deciders $H_t$ or $H_f$. The addition surmounts to simply matching the encoding of $P$ and just returning $H_t$ case, true, and in $H_f$, false. One of these halting deciders will correctly decide wether $P$ halts or not. Thus we have in one of $H_t$, or $H_f$, a halting decider for the set of programs $L \cup \{P\}$, which contradicts the assumption that we found the largest decidable set.
	\end{answered}

\item{\textbf{The decidability criterion cannot be replaced by the weaker condition, there exists an $n > 0$}}

	\begin{answered}
		Recall; the decidability criterion says that for some program $P$ and a fixed $n > 0$. If we know the number of inputs $v$ of length less than or equal to $n$ for which $P(v)$ stops, then the halting problem for the set $\{(P,v) | length(v) \leq n \}$ is decidable.

		The proof relies on the establishing of a finite set of programs of length at most $n$ encoded over a finite alphabet. Perhaps the weaker condition maneuvre's this to an unbounded set of programs, causing us to not be able to run these programs in parallel?
	\end{answered}

\item{\textbf{Restricting the class of programs does not diminish the generality of the Halting Problem proof}}

	\begin{answered}
		Clearly! If we cannot find a decider for the set of program and input pairs $L$, then for some $P \not\in L$ we could also not find a halting decider for the set of program and input pairs $L \cup \{P\}$. Considering programs are encoded over a finite alphabet, the set of all programs is countable, and so we can recursively use the above method to show that there is also no halting decider for \emph{all} program input pairs.
	\end{answered}

\item{\textbf{does the following program solve the halting problem}}
	\begin{answered}
		\begin{algorithmic}[1]
	\REQUIRE $P, N$
	\STATE $P(N)$
	\RETURN YES
\end{algorithmic}
For this program to solve the halting problem, this must be interpreted as a candidate halting decider, indeed it satisfies the condition that it can determine wether $P(N)$ halts. The issue is, that this program must in \emph{finite time} conclude this. Assuming time and the number of instructions are executed per unit of time, that means there is a fixed limit, say $T$ instructions, that this algorithm must execute less than to decide wether $P(N)$ halts.

We can quite easily construct an algorithm that has $T+1$ instructions however and this would be an example of a program this halting decider cannot determine wether it halts or not. 
	\end{answered}

\item{\textbf{Write a universal pseudo-code program U}}

	\begin{answered}
	Recall; a universal pseudo-code program, first defined by Turing, is a pseudocode program that can simulate an arbitrary Turing machine on every arbitrary input. Achieved by reading both the code/description of the machine to be simulated as well as the input. This is a well known topic.
	\end{answered}

	\section{Program Size Complexity}

\item{\textbf{Construction of universal PF program with bounded program complexity;}}
show that one can effectively construct a prefix-free program $U$ such that for every prefix-free program $C$ there effectively exists a constant $c=c_{U,C}$ such that for each input string $x$ we have $H_U(x)\leq H_C(x)+c$.

\begin{answered}
	Let $C_i$ be a computably enumeration of all prefix-free programs (programs are finite strings over a finite alphabet).
	Construct U by $U(1^i0\alpha) = C_i(\alpha)$. U is prefix-free.

	For any $C_i$ we have $c_{U,C_i} = 1^i0$. It holds for some $x \in dom(U) \cap dom(C_i)$;
	\begin{equation}
		H_u(x) \leq |1^i0l^*| \text{ where } l^* = min\{l \,|\, C_i(l) = x\}
	\end{equation}
	\begin{equation}
		|1^i0l^*| = |c_{U,C_i}| + |l^*| = |c_{U,C_i}| + H_{C_i}(x)
	\end{equation}

	As required $H_u(x) \leq H_C(x) + c$. (where c in this case is just $|c_{U,C_i}|$)

\end{answered}

\item{Let $C_i$ be a computably enumeration of all prefix-free programs (programs are finite strings over a finite alphabet).}
	
	Construct U by $U(1^i0\alpha) = C_i(\alpha)$. Show U is prefix-free.

	\begin{answered}
		Give me some input for U, say $y$. By definition $y = 1^k0x$ for some $k \in N$ and $x \in B^*$. It's obvious that the substring $1^k0$ uniquely identifies $C_k$. Also since $C_k$ is prefix free, it's clear $x$ uniquely identifies a single element in the $dom(C_k)$.
	\end{answered}

	Need \textbf{take two} (below)

\item{Let $C_i$ be a computably enumeration of all prefix-free programs (programs are finite strings over a finite alphabet).}
	
	Construct U by $U(1^i0\alpha) = C_i(\alpha)$. Show U is prefix-free.

	\begin{answered}
		Assume one finds two elements in the domain of $U$, call them $p$ and $p'$ such that $p$ is a proper substring of $p'$.

		By definition of $U$, respectively these strings have the form $p = 1^k0x$ and $p' = 1^l0xx'$ for $k,l \in \mathbb{N}$ and $x,x',z \in B^*$. By assumption $\Rightarrow k = l$ as if this was not the case, you'd have $1^l0 != 1^k0$. $\Rightarrow x, xx' \in dom(C_{l})$. But $C_{l}$ is prefix-free. Contradiction.
	\end{answered}

\item{\textbf{Prove that Chaitins constant is a viable probability}}

	\begin{answered}
		That is; prove that for every prefix-free set $S \in B*$,
		\begin{equation}
			\Omega_S=\sum_{s \in S} 2^{|-s|} \leq 1 \notag \\
		\end{equation}

		Set n to be the length of longest string in S. Build for each $s\in S$
		\begin{equation}
			C_{s} = \{sb \mid b \in B^* \text{ and } |sb| = n\} \notag \\
		\end{equation}
		It's then the case that $|C_{s}| = 2^{n-|s|}$. By assumption for any $s,b \in S$ being prefix-free, then $C_s \cap C_p = \emptyset$ when $s \not = b$.

		\begin{equation}
			2^n = |B^n| \geq \sum_{s \in S} |C_s| = \sum_{s \in S} 2^{n - |s|} \notag
		\end{equation}

		Dividing both sides by $2^n$. We get to what is required.
	\end{answered}

\end{enumerate}
\end{document}
